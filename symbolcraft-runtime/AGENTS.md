
  🎯 SymbolCraft 实现内置图标库的方案

  方案 1: 预生成 AAR/JAR 库 (推荐 ⭐⭐⭐⭐⭐)

  核心思路:
  - 预先生成所有 Material Symbols 图标到独立库
  - 结合 Tree Shaking 在编译时剔除未使用的图标
  - 类似 material-icons-extended 的使用体验

  架构设计

  symbolcraft-runtime/              # 运行时核心库 (50KB)
  ├── Icons.kt                      # 图标访问入口
  └── LazyImageVector.kt           # 懒加载支持

  symbolcraft-material-symbols/     # 预生成图标库 (按需拆分)
  ├── outlined/                     # 3000+ 图标 × 7 权重 = 21000 个
  │   ├── weight-400/               # 单独模块 (~2MB)
  │   ├── weight-500/
  │   └── weight-700/
  ├── rounded/
  └── sharp/

  symbolcraft-compiler/             # 编译器插件
  └── TreeShakingTransformer.kt    # R8/ProGuard 规则生成

  实现步骤

  步骤 1: 创建独立图标库项目

  // symbolcraft-material-symbols/build.gradle.kts
  plugins {
      kotlin("multiplatform")
      id("com.android.library")
  }

  kotlin {
      androidTarget()
      jvm()
      iosArm64()
      iosSimulatorArm64()

      sourceSets {
          commonMain {
              dependencies {
                  api(project(":symbolcraft-runtime"))
              }
          }
      }
  }

  // 构建时运行生成任务
  tasks.register("generateAllIcons") {
      doLast {
          // 使用 SymbolCraft 插件生成所有图标
          // 输出到 src/commonMain/kotlin/generated/
      }
  }

  步骤 2: 设计懒加载机制

  // symbolcraft-runtime/src/commonMain/kotlin/Icons.kt
  package io.github.kingsword09.symbolcraft.runtime

  import androidx.compose.ui.graphics.vector.ImageVector

  /**
   * 图标访问入口
   * 类似 androidx.compose.material.icons.Icons
   */
  object MaterialSymbols {
      object Outlined {
          object W400 {
              val Home: ImageVector by lazy {
                  io.github.kingsword09.symbolcraft.icons.outlined.w400.HomeIcon
              }
              val Search: ImageVector by lazy {
                  io.github.kingsword09.symbolcraft.icons.outlined.w400.SearchIcon
              }
              // ... 3000+ 图标
          }
          object W500 { /* ... */ }
          object W700 { /* ... */ }
      }

      object Rounded { /* ... */ }
      object Sharp { /* ... */ }
  }

  步骤 3: 生成 Tree Shaking 规则

  // symbolcraft-compiler/src/main/kotlin/TreeShakingTransformer.kt
  class SymbolCraftTreeShakingTask : DefaultTask() {

      @TaskAction
      fun generateProguardRules() {
          val usedIcons = analyzeUsedIcons()

          // 生成 R8/ProGuard 规则
          val rules = buildString {
              appendLine("# SymbolCraft Tree Shaking Rules")
              appendLine("# Generated by SymbolCraft Compiler")
              appendLine()

              // 保留使用的图标
              for (icon in usedIcons) {
                  appendLine("-keep class ${icon.fullyQualifiedName} { *; }")
              }

              // 移除未使用的图标
              appendLine("-assumenosideeffects class io.github.kingsword09.symbolcraft.icons.** {")
              appendLine("    <init>(...);")
              appendLine("}")
          }

          File("build/symbolcraft/proguard-rules.pro").writeText(rules)
      }
  }

  步骤 4: 用户使用方式

  // build.gradle.kts
  dependencies {
      // 方式1: 完整库 (含所有权重和样式)
      implementation("io.github.kingsword09:symbolcraft-material-symbols:0.4.0")

      // 方式2: 按需引入 (推荐)
      implementation("io.github.kingsword09:symbolcraft-material-symbols-outlined-w400:0.4.0")
      implementation("io.github.kingsword09:symbolcraft-material-symbols-rounded-w500:0.4.0")
  }

  // App.kt
  import io.github.kingsword09.symbolcraft.MaterialSymbols

  @Composable
  fun MyScreen() {
      // 直接使用，类似 material-icons-extended
      Icon(
          imageVector = MaterialSymbols.Outlined.W400.Home,
          contentDescription = "Home"
      )

      Icon(
          imageVector = MaterialSymbols.Rounded.W500.Search,
          contentDescription = "Search"
      )
  }

  方案 2: Gradle 插件 + 本地缓存 (当前方案增强)

  保持当前 SymbolCraft 插件方式，但增加便利性:

  symbolCraft {
      // 新增: 快速启用模式
      presets {
          materialSymbolsAll(
              weights = listOf(400, 500, 700),
              variants = listOf(SymbolVariant.OUTLINED, SymbolVariant.ROUNDED)
          )
      }

      // 启用智能 Tree Shaking
      treeShaking {
          enabled = true
          mode = TreeShakingMode.AUTO  // 自动分析并过滤
      }
  }

  自动生成所有图标索引:

  // 生成 MaterialSymbolsIndex.kt
  object MaterialSymbolsIndex {
      val allIcons = setOf(
          "home", "search", "settings", /* 3000+ 个图标名 */
      )

      fun generateAll() {
          allIcons.forEach { iconName ->
              // 按需生成
          }
      }
  }

  方案 3: 混合方案 (最佳体验 ⭐⭐⭐⭐⭐)

  结合方案 1 和方案 2 的优点:

  // 1. 开发阶段: 使用预构建库
  dependencies {
      debugImplementation("io.github.kingsword09:symbolcraft-material-symbols:0.4.0")
  }

  // 2. 生产构建: 自动 Tree Shaking
  plugins {
      id("io.github.kingsword09.symbolcraft") version "0.4.0"
  }

  symbolCraft {
      // 自动替换为精简版本
      treeShaking {
          enabled = true
          replaceDebugLibrary = true  // Release 时替换为生成的图标
      }
  }

  📊 方案对比

  | 特性           | Material Icons Extended | 方案1 (预生成库) | 方案2 (增强插件) | 方案3 (混合) |
  |--------------|-------------------------|------------|------------|----------|
  | 零配置使用        | ✅                       | ✅          | ❌ (需配置)    | ✅        |
  | 包体积          | ❌ 11.3MB                | ⚠️ 取决于拆分   | ✅ 最小       | ✅ 最小     |
  | IDE 体验       | ✅ 完美                    | ✅ 完美       | ⚠️ 一般      | ✅ 完美     |
  | 样式定制         | ❌                       | ⚠️ 有限      | ✅ 完全定制     | ✅ 完全定制   |
  | Tree Shaking | ❌                       | ✅          | ✅          | ✅        |
  | 构建速度         | ✅ 快                     | ✅ 快        | ⚠️ 较慢      | ✅ 快      |

  🛠 实施方案 (混合方案详细设计)

  1. 项目结构

  SymbolCraft/
  ├── symbolcraft-runtime/          # 运行时核心
  │   └── src/commonMain/kotlin/
  │       └── MaterialSymbols.kt
  │
  ├── symbolcraft-material-symbols/ # 预生成库
  │   ├── full/                     # 完整版 (所有图标)
  │   ├── outlined-w400/            # 拆分模块
  │   ├── outlined-w500/
  │   └── rounded-w500/
  │
  ├── symbolcraft-compiler/         # 编译器插件
  │   └── TreeShakingPlugin.kt
  │
  └── symbolcraft-gradle-plugin/    # Gradle 插件 (现有)

  2. 预生成脚本

  // scripts/GeneratePrebuiltLibrary.main.kts
  import io.github.kingsword09.symbolcraft.*

  /**
   * 生成预构建图标库
   * 运行: ./gradlew :symbolcraft-material-symbols:generatePrebuilt
   */
  val generator = PrebuiltLibraryGenerator(
      outputDir = File("symbolcraft-material-symbols/full/src/commonMain/kotlin"),
      packageName = "io.github.kingsword09.symbolcraft.icons"
  )

  // 生成所有图标
  val allMaterialSymbols = fetchAllIconNames() // 从 Google Fonts API 获取
  allMaterialSymbols.forEach { iconName ->
      listOf(400, 500, 700).forEach { weight ->
          SymbolVariant.values().forEach { variant ->
              generator.generateIcon(
                  name = iconName,
                  weight = weight,
                  variant = variant
              )
          }
      }
  }

  generator.generateIndex() // 生成索引文件

  3. Tree Shaking 集成

  // symbolcraft-compiler/src/main/kotlin/TreeShakingPlugin.kt
  class SymbolCraftCompilerPlugin : KotlinCompilerPluginSupportPlugin {

      override fun apply(target: Project) {
          // 在编译前分析图标使用情况
          target.tasks.withType<KotlinCompile>().configureEach {
              doFirst {
                  val analyzer = IconUsageAnalyzer()
                  val usedIcons = analyzer.analyze(target)

                  // 生成保留规则
                  generateKeepRules(usedIcons, target)
              }
          }
      }

      private fun generateKeepRules(icons: Set<String>, project: Project) {
          val rulesFile = project.file("build/symbolcraft/keep-rules.pro")
          rulesFile.writeText("""
              # Keep used Material Symbols
              ${icons.joinToString("\n") { "-keep class $it { *; }" }}
              
              # Remove unused icons
              -assumenosideeffects class io.github.kingsword09.symbolcraft.icons.** {
                  <init>(...);
              }
          """.trimIndent())

          // 自动添加到 Android proguardFiles
          project.android?.defaultConfig?.proguardFiles(rulesFile)
      }
  }

  4. 用户体验

  开发阶段

  // build.gradle.kts
  dependencies {
      // 开发时使用完整库，IDE 自动补全
      debugImplementation("io.github.kingsword09:symbolcraft-material-symbols-full:0.4.0")
  }

  // App.kt
  import io.github.kingsword09.symbolcraft.MaterialSymbols

  @Composable
  fun MyScreen() {
      Icon(MaterialSymbols.Outlined.W400.Home, "Home")
      Icon(MaterialSymbols.Rounded.W500.Search, "Search")
  }

  生产构建

  // build.gradle.kts
  plugins {
      id("io.github.kingsword09.symbolcraft") version "0.4.0"
  }

  symbolCraft {
      treeShaking {
          enabled = true

          // 自动模式: 分析代码并生成最小集
          mode = TreeShakingMode.AUTO

          // Release 构建时替换为生成的图标
          replaceInRelease = true
      }
  }

  // 构建输出:
  // ✅ Debug APK: 15MB (使用预构建库)
  // ✅ Release APK: 5MB (使用 Tree Shaking 后的精简版)

  🚀 实施路线图

  第一阶段 (2周)

  1. ✅ 创建 symbolcraft-runtime 模块
  2. ✅ 实现懒加载机制
  3. ✅ 生成 100 个常用图标作为 MVP

  第二阶段 (3周)

  4. ✅ 完善预生成脚本
  5. ✅ 生成所有 Material Symbols 图标
  6. ✅ 按权重/样式拆分模块

  第三阶段 (2周)

  7. ✅ 实现编译器插件
  8. ✅ 集成 Tree Shaking
  9. ✅ 测试混合方案

  第四阶段 (1周)

  10. ✅ 文档和示例
  11. ✅ 发布 v0.4.0

  💡 技术挑战与解决方案

  挑战 1: 图标数量巨大

  问题: Material Symbols 有 3000+ 图标 × 7 权重 × 3 样式 = 63,000 个文件

  解决方案:
  // 使用代码生成器 + Gradle 缓存
  tasks.register("generateMaterialSymbols") {
      inputs.property("version", "1.0.0")
      outputs.dir("build/generated/material-symbols")

      doLast {
          // 并行生成
          launch {
              iconNames.chunked(100).map { chunk ->
                  async { generateIconsForChunk(chunk) }
              }.awaitAll()
          }
      }
  }

  挑战 2: IDE 性能

  问题: 63,000 个类可能导致 IDE 卡顿

  解决方案:
  // 使用索引 + 动态生成
  object MaterialSymbols {
      private val cache = ConcurrentHashMap<String, ImageVector>()

      operator fun get(name: String): ImageVector {
          return cache.getOrPut(name) {
              loadIcon(name) // 动态加载
          }
      }
  }

  挑战 3: Tree Shaking 准确性

  问题: 动态引用难以检测

  解决方案:
  // 提供注解标记
  @KeepIcons("home", "search", "settings")
  @Composable
  fun MyScreen() {
      // Tree Shaking 会保留这些图标
  }

  📝 总结

  可行性评估: ✅ 完全可行

  推荐方案: 混合方案 (方案 3)
  - 开发体验接近 material-icons-extended
  - 生产包体积接近当前 SymbolCraft
  - Tree Shaking 自动优化

  核心优势:
  - 零配置使用 (开发阶段)
  - 自动优化 (生产构建)
  - 完全定制 (高级用户)


  SymbolCraft Runtime 模块开发方案

  📐 模块架构

  symbolcraft-runtime/
  ├── build.gradle.kts
  ├── src/
  │   ├── commonMain/kotlin/io/github/kingsword09/symbolcraft/runtime/
  │   │   ├── MaterialSymbols.kt          # 主访问入口
  │   │   ├── IconLoader.kt               # 图标加载器
  │   │   ├── IconCache.kt                # 缓存管理
  │   │   ├── IconProvider.kt             # 图标提供者接口
  │   │   ├── LazyImageVector.kt          # 懒加载包装器
  │   │   └── exceptions/
  │   │       └── IconNotFoundException.kt
  │   │
  │   ├── androidMain/kotlin/
  │   │   └── PlatformIconLoader.android.kt
  │   │
  │   ├── jvmMain/kotlin/
  │   │   └── PlatformIconLoader.jvm.kt
  │   │
  │   ├── iosMain/kotlin/
  │   │   └── PlatformIconLoader.ios.kt
  │   │
  │   └── commonTest/kotlin/
  │       └── MaterialSymbolsTest.kt
  │
  └── README.md

  🏗 详细实现

  1. build.gradle.kts

  import org.jetbrains.kotlin.gradle.dsl.JvmTarget

  plugins {
      alias(libs.plugins.kotlinMultiplatform)
      alias(libs.plugins.androidLibrary)
      alias(libs.plugins.composeMultiplatform)
      alias(libs.plugins.composeCompiler)
      alias(libs.plugins.maven.publish)
      signing
  }

  group = "io.github.kingsword09"
  version = "0.4.0"

  kotlin {
      jvmToolchain(17)

      // 目标平台
      androidTarget {
          compilerOptions {
              jvmTarget.set(JvmTarget.JVM_17)
          }
      }

      jvm()

      listOf(
          iosArm64(),
          iosSimulatorArm64(),
          iosX64()
      ).forEach { iosTarget ->
          iosTarget.binaries.framework {
              baseName = "SymbolCraftRuntime"
              isStatic = true
          }
      }

      // JS 支持 (可选)
      js(IR) {
          browser()
          nodejs()
      }

      sourceSets {
          commonMain.dependencies {
              // Compose 核心依赖
              implementation(compose.runtime)
              implementation(compose.ui)

              // Kotlin 协程 (用于异步加载)
              implementation(libs.kotlinx.coroutines.core)
          }

          commonTest.dependencies {
              implementation(kotlin("test"))
              implementation(libs.kotlinx.coroutines.test)
          }

          androidMain.dependencies {
              implementation(libs.androidx.core.ktx)
          }
      }
  }

  android {
      namespace = "io.github.kingsword09.symbolcraft.runtime"
      compileSdk = 34

      defaultConfig {
          minSdk = 21
      }

      compileOptions {
          sourceCompatibility = JavaVersion.VERSION_17
          targetCompatibility = JavaVersion.VERSION_17
      }
  }

  // Maven 发布配置
  mavenPublishing {
      publishToMavenCentral(automaticRelease = true)
      signAllPublications()

      coordinates(
          groupId = group.toString(),
          artifactId = "symbolcraft-runtime",
          version = version.toString()
      )

      pom {
          name.set("SymbolCraft Runtime")
          description.set("Runtime library for SymbolCraft icon system")
          url.set("https://github.com/kingsword09/SymbolCraft")

          licenses {
              license {
                  name.set("Apache License 2.0")
                  url.set("https://www.apache.org/licenses/LICENSE-2.0.txt")
              }
          }

          developers {
              developer {
                  id.set("kingsword09")
                  name.set("kingsword09")
                  email.set("kingsword09@gmail.com")
              }
          }

          scm {
              url.set("https://github.com/kingsword09/SymbolCraft")
              connection.set("scm:git:git://github.com/kingsword09/SymbolCraft.git")
          }
      }
  }
